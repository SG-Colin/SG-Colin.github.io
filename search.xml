<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>NexT 主题优化</title>
    <url>/2020/07/22/Next/</url>
    <content><![CDATA[<p>简单记录一下优化 NexT 主题过程中的一些细节。</p>
<p>There is a negligible beginning in all great action and thought.</p>
<a id="more"></a>
<h3 id="圆角设置"><a href="#圆角设置" class="headerlink" title="圆角设置"></a>圆角设置</h3><p>此优化仅对 Pisces 和 Gemini 主题适用。</p>
<p>(以 Pisces 为例）修改文件 <code>\themes\next\source\css\_variables\Pisces.styl</code></p>
<p>将 <code>Borders</code> 下对应位置的 <code>initial</code> 改为</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$border-radius-inner            = 15px 15px 15px 15px;</span><br><span class="line">$border-radius                  = 15px;</span><br></pre></td></tr></table></figure>
<h3 id="背景色更换"><a href="#背景色更换" class="headerlink" title="背景色更换"></a>背景色更换</h3><p>修改文件 <code>themes\next\source\css\_custom\custom.styl</code> ，添加：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#F0F0F0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="去除顶部细线"><a href="#去除顶部细线" class="headerlink" title="去除顶部细线"></a>去除顶部细线</h3><p>修改文件 <code>themes\next\source\css\_custom\custom.styl</code> </p>
<p>添加代码 <code>.headband {display:none;}</code></p>
<h3 id="页面宽度位置设置"><a href="#页面宽度位置设置" class="headerlink" title="页面宽度位置设置"></a>页面宽度位置设置</h3><p>修改文件 <code>themes\next\source\css\_custom\custom.styl</code> ，添加：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.content-wrap &#123;</span><br><span class="line">    margin: 25px auto;</span><br><span class="line">    padding-top: 40px;</span><br><span class="line">    padding-right: 100px;</span><br><span class="line">    padding-bottom: 40px;</span><br><span class="line">    padding-left: 100px;</span><br><span class="line">    width: calc(100% - 280px);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.header-inner &#123;</span><br><span class="line">    margin: 25px auto;</span><br><span class="line">&#125;</span><br><span class="line">.sidebar-inner &#123;</span><br><span class="line">    margin: 25px auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实想要修改页面形态效果，直接在对应的网页 <code>Styles</code>上修改，然后复制到 <code>custom.styl</code> 即可。</p>
<h3 id="Sidebar-头像链接主页"><a href="#Sidebar-头像链接主页" class="headerlink" title="Sidebar 头像链接主页"></a>Sidebar 头像链接主页</h3><p>修改文件 <code>themes\next\layout\_macro\sidebar.swig</code>，找到对应位置：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"site-author-image"</span> <span class="attr">itemprop</span>=<span class="string">"image"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">src</span>=<span class="string">"&#123;&#123; url_for( theme.avatar | default(theme.images + '/avatar.gif') ) &#125;&#125;"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">alt</span>=<span class="string">"&#123;&#123; theme.author &#125;&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>找到中间三行，添加第一行 <code>&lt;a href=&quot;/&quot;&gt;</code> 和最后一行 <code>&lt;/a&gt;</code> 即可，中间部分不用修改。</p>
<h3 id="Sidebar-posts-链接修复"><a href="#Sidebar-posts-链接修复" class="headerlink" title="Sidebar posts 链接修复"></a>Sidebar posts 链接修复</h3><p>修改文件 <code>themes/next/layout/_macro/sidebar.swing</code> ，找到对应位置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> config.archive_dir != <span class="string">'/'</span> and site.posts.length &gt; <span class="number">0</span> %&#125;</span><br><span class="line">	&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"site-state-item site-state-posts"</span>&gt;</span><br><span class="line">    	&#123;% <span class="keyword">if</span> theme.menu.archives %&#125;</span><br><span class="line">        	&lt;a href=<span class="string">"&#123;&#123; url_for(theme.menu.archives).split('||')[0] | trim &#125;&#125;"</span>&gt;</span><br><span class="line">        &#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">            &lt;a href=<span class="string">"&#123;&#123; url_for(config.archive_dir) &#125;&#125;"</span>&gt;</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">            	&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"site-state-item-count"</span>&gt;&#123;&#123; site.posts.length &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">            	&lt;span class="site-state-item-name"&gt;&#123;&#123; __('state.posts') &#125;&#125;&lt;/</span>span&gt;</span><br><span class="line">      		&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>删掉判断部分，保留 <code>else</code> 的内容，即：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> config.archive_dir != <span class="string">'/'</span> and site.posts.length &gt; <span class="number">0</span> %&#125;</span><br><span class="line">	&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"site-state-item site-state-posts"</span>&gt;</span><br><span class="line">    	&lt;a href=<span class="string">"&#123;&#123; url_for(config.archive_dir) &#125;&#125;"</span>&gt;</span><br><span class="line">        	&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"site-state-item-count"</span>&gt;&#123;&#123; site.posts.length &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">            &lt;span class="site-state-item-name"&gt;&#123;&#123; __('state.posts') &#125;&#125;&lt;/</span>span&gt;</span><br><span class="line">        &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sidebar-Social-开关"><a href="#Sidebar-Social-开关" class="headerlink" title="Sidebar Social 开关"></a>Sidebar Social 开关</h3><p>修改文件 <code>themes/next/_config.yml</code> ，搜索 <code>social</code>，打开你想要的开关。</p>
<p>貌似一些 <code>Social</code> 开关是隐藏的，比如 <code>QQ</code> ， <code>Wechat</code> 或 <code>Weibo</code> ，仿照格式写就可以。</p>
<p>如果想只显示图标（如本站），打开 <code>social_icons</code> 下的 <code>icons_only</code> 开关即可。</p>
<h3 id="Sidebar-显示进度条和返回"><a href="#Sidebar-显示进度条和返回" class="headerlink" title="Sidebar 显示进度条和返回"></a>Sidebar 显示进度条和返回</h3><p>修改文件 <code>themes/next/_config.yml</code> ，搜索关键字 <code>b2t</code> ，把这两个选项改为 <code>true</code> ：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Back to top in sidebar</span></span><br><span class="line"><span class="attr">b2t:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Scroll percent label in b2t button</span></span><br><span class="line"><span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="pdf-文件显示"><a href="#pdf-文件显示" class="headerlink" title="pdf 文件显示"></a>pdf 文件显示</h3><p>参考：<a href="https://blog.csdn.net/wugenqiang/article/details/88377669" target="_blank" rel="noopener">Hexo NexT主题内添加pdf 插件</a></p>
<h3 id="折叠展开功能"><a href="#折叠展开功能" class="headerlink" title="折叠展开功能"></a>折叠展开功能</h3><p>参考：<a href="https://www.cnblogs.com/woshimrf/p/hexo-fold-block.html" target="_blank" rel="noopener">Hexo NexT 主题内添加折叠块功能</a></p>
<h3 id="修改文章-Tag-图标"><a href="#修改文章-Tag-图标" class="headerlink" title="修改文章 Tag 图标"></a>修改文章 Tag 图标</h3><p>修改文件 <code>/themes/next/layout/_macro/post.swing</code> </p>
<p>搜索 <code>rel=&quot;tag&quot;&gt;#</code> 将 <code>#</code> 替换为 <code>&lt;i class=&quot;fa fa-envira&quot;&gt;&lt;/i&gt;</code>，即可显示 fa-tag 图标。</p>
<p>To be continued…</p>
]]></content>
  </entry>
  <entry>
    <title>线性筛与积性函数</title>
    <url>/2020/07/23/%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>线性筛是一种数论筛法，可以筛出一定范围内的质数或<strong>任意积性函数</strong>的值。</p>
<p>其中”线性“的含义为 <strong>每个数字只被其最小的质因数筛出</strong> ，并非时间复杂度。</p>
<p>假设求积性函数 $f(x)$ 的质数幂 $f(p^k)$ 复杂度为 $t$，则最终复杂度为 $ O(n+\frac{n}{\ln n}\times  t)$ 。</p>
<a id="more"></a>
<h3 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h3><p>定义域为正整数集 $\mathbb N^+$，陪域为复数集 $\mathbb C$ 的函数。</p>
<p>常见的数论函数可视为，定义域为正整数，值域为整数的函数。</p>
<h3 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h3><p>对于一个数论函数 $f$ ， $\forall\ a\ \bot\ b,\ f(ab) = f(a)\times f(b)$，则称 $f$ 为<strong>积性函数</strong>。</p>
<p>若 $n$ 的标准分解为 $n = p_1^{k_1}\times p_2^{k_2}\times …\times p_m^{k_m}\ (p_1&lt;p_2&lt;…&lt;p_m)$ ，则</p>
<script type="math/tex; mode=display">
f(n)=\prod_{i=1}^m f(p_i^{k_i})</script><p>这也是线性筛的基础，即积性函数的基本性质之一就是可被线性筛。</p>
<h3 id="完全积性函数"><a href="#完全积性函数" class="headerlink" title="完全积性函数"></a>完全积性函数</h3><p>对于一个数论函数 $f$ ， $\forall\ a,b\in \mathbb N^+ ,\ f(ab) = f(a)\times f(b)$，则称 $f$ 为<strong>完全积性函数</strong>。</p>
<hr>
<h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><p>求 $f(n)$ 的值时，考虑其标准分解 </p>
<script type="math/tex; mode=display">
n = p_1^{k_1}\times p_2^{k_2}\times ...\times p_m^{k_m}\ (p_1<p_2<...<p_m)</script><p>对标准分解的最小质因数的指数 $k_1$ 的情况讨论。</p>
<ul>
<li><p>$n$ 是素数 $p_1$，即 $k_1=m=1$</p>
</li>
<li><p>$n=p_1\times i$，其中 $i$ 是任意正整数，且 $k_1=1$，即 $p_1\nmid i$ </p>
</li>
<li><p>$n=p_1\times i$，其中 $i$ 是任意正整数，且 $k_1&gt;1$，即 $p_1\mid i$ </p>
</li>
</ul>
<p>下面对三类情况分别进行处理：</p>
<ul>
<li><p>$n$ 是素数 $p_1$，即 $k_1=m=1$</p>
<p>往往可以利用数论函数的定义快速求出。</p>
</li>
<li><p>$n=p_1\times i$，其中 $i$ 是任意正整数，且 $k_1=1$，即 $p_1\nmid i$ </p>
<p>利用积性函数的定义，由于 $p_1\bot i$，有 $f(n) = f(p_1) \times f(i)$</p>
<p>由于 $p_1&lt;n,\ i&lt;n$，$f(p_1)$ 和 $f(i)$ 在此前都已求出。</p>
</li>
<li><p>$n=p_1\times i$，其中 $i$ 是任意正整数，且 $k_1&gt;1$，即 $p_1\mid i$ </p>
<p>将 $n$ 重新表示为 $n=p_1^{k_1}\times j$ 的形式，此时 $p_1^{k_1}\bot j$，有$f(n)=f(p_1^{k_1})\times f(j)$</p>
<p>由于 $p_1^{k_1}&lt;n, j&lt;n$，$f(p_1^{k_1})$ 和 $f(j)$ 在此前都已求出。</p>
</li>
</ul>
<p>现在只需要解决如何快速求出 $n$ 对应的 $p_1^{k_1}$ 和 $k_1$ 的值。</p>
<p>不妨设 $g(n)=p_1^{k_1},\ k(n)=k_1$，这两个函数虽然不是积性的，但依然可以按照上述思路讨论。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$n$ 与 $p_1$ 关系</th>
<th style="text-align:center">$g(n)$</th>
<th style="text-align:center">$k(n)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$n$ 是素数 $p_1$</td>
<td style="text-align:center">$p_1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$n=p_1\times i$，且 $p_1\nmid i$</td>
<td style="text-align:center">$p$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$n=p_1\times i$，且 $p_1\mid i$</td>
<td style="text-align:center">$g(i)\times p_1$</td>
<td style="text-align:center">$k(i)+1$</td>
</tr>
</tbody>
</table>
</div>
<p>因此我们可以在线性筛的同时求出 $g(n)$ 和 $k(n)$，复杂度不变。</p>
<hr>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>下面展示一些积性函数的线性筛法。</p>
<p>对应函数的积性证明参考 <a href="">这里</a> ，本篇不再证明。</p>
<p>下面提到的 $n,m,i,j,p,k$ 的定义与上述内容相同。</p>
<h4 id="线性筛质数"><a href="#线性筛质数" class="headerlink" title="线性筛质数"></a>线性筛质数</h4><p>本质上是筛 <strong>最小质因数</strong> $d_{min}(n)=p_1$，若 $d_{min}(n)=n$ 则这个数为质数。</p>
<p>这个函数也不是积性函数，但是对于由当前质数 $p_i$ 筛掉的任意合数 $n$，都有 $d_{min}(n)=p_i$</p>
<div><div class="fold_hider"><div class="close hider_title">Sample-Code</div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mindiv[i]) prime[++tot] = mindiv[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime[j] &gt; mindiv[i] || prime[j] * i &gt; n) <span class="keyword">break</span>;</span><br><span class="line">    	mindiv[prime[j] * i] = prime[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h4 id="线性筛-mu"><a href="#线性筛-mu" class="headerlink" title="线性筛 $\mu$"></a>线性筛 $\mu$</h4><p>莫比乌斯函数 $\mu$ 是积性函数，定义为</p>
<script type="math/tex; mode=display">
\mu(n)= \begin{cases} 1 \qquad & n=1 \\ (-1)^k \qquad & n=\Pi_{i=1}^{k} p_i \\ 0 \qquad & \text{otherwise} \end{cases}</script><p>易得 $\mu(p_i^k)=0(k&gt;1)$，直接按条件分讨就可以。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$n$ 与 $p_1$ 关系</th>
<th style="text-align:center">$\mu(n)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$n$ 是素数 $p_1$</td>
<td style="text-align:center">$-1$</td>
</tr>
<tr>
<td style="text-align:center">$n=p_1\times i$，且 $p_1\nmid i$</td>
<td style="text-align:center">$\mu(p_1)\times \mu(i)=-\mu(i)$</td>
</tr>
<tr>
<td style="text-align:center">$n=p_1\times i$，且 $p_1\mid i$</td>
<td style="text-align:center">$\mu(p_1^{k_1})\times\mu(j)=0$</td>
</tr>
</tbody>
</table>
</div>
<div><div class="fold_hider"><div class="close hider_title">Sample-Code</div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mindiv[i]) prime[++tot] = mindiv[i] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime[j] &gt; mindiv[i] || prime[j] * i &gt; n) <span class="keyword">break</span>;</span><br><span class="line">    	mindiv[prime[j] * i] = prime[j];</span><br><span class="line">        mu[prime[j] * i] = (i % prime[j]) ? -mu[i] : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h4 id="线性筛-varphi"><a href="#线性筛-varphi" class="headerlink" title="线性筛 $\varphi$"></a>线性筛 $\varphi$</h4><p>欧拉函数 $\varphi$ 是积性函数，定义为 </p>
<script type="math/tex; mode=display">
\varphi(n)=\sum_{i=1}^n[i\bot n]</script><p>同时有 $\varphi$ 计算公式（证明见<a href="">这里</a>) </p>
<script type="math/tex; mode=display">
\varphi(n)=n\prod_{i=1}^m \frac{p_i-1}{p_i}</script><p>由计算公式知，第三类情况 </p>
<script type="math/tex; mode=display">
\varphi(n)=\varphi(p_1^k)\times\varphi(j)=(p_1-1)\times p_1^{k-1}\times \varphi(j)\\
\varphi(i)=\varphi(p_1^{k_1-1})\times \varphi(j)=(p_1-1)\times p_1^{k_1-2}\times \varphi(j)</script><p>因此有 </p>
<script type="math/tex; mode=display">
\varphi(n)=\varphi(i)\times p_1</script><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$n$ 与 $p_1$ 关系</th>
<th style="text-align:center">$\varphi(n)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$n$ 是素数 $p_1$</td>
<td style="text-align:center">$n-1$</td>
</tr>
<tr>
<td style="text-align:center">$n=p_1\times i$，且 $p_1\nmid i$</td>
<td style="text-align:center">$\varphi(p_1)\times \varphi(i)=(p_1-1)\times \varphi(i)$</td>
</tr>
<tr>
<td style="text-align:center">$n=p_1\times i$，且 $p_1\mid i$</td>
<td style="text-align:center">$\varphi(p_1^k)\times\varphi(j)=p_1\times \varphi(i)$</td>
</tr>
</tbody>
</table>
</div>
<div><div class="fold_hider"><div class="close hider_title">Sample-Code</div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!phi[i]) prime[++tot] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime[j] &gt; mindiv[i] || prime[j] * i &gt; n) <span class="keyword">break</span>;</span><br><span class="line">    	phi[prime[j] * i] = phi[i] * ((i % prime[j]) ? prime[j] - <span class="number">1</span> : prime[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h4 id="关于-sigma-k"><a href="#关于-sigma-k" class="headerlink" title="关于 $\sigma_k$"></a>关于 $\sigma_k$</h4><p>约束幂和函数 $\sigma_k$ 是积性函数，定义为</p>
<script type="math/tex; mode=display">
\sigma_k(n)=\sum_{d|n}d^k</script><p>也就是说，$\sigma_k$ 是一个函数族，代表 $n$ 的约数的 $k$ 次幂和。</p>
<p>下面我们从简到难介绍 $\sigma_k$ 的求法。</p>
<h4 id="线性筛-tau"><a href="#线性筛-tau" class="headerlink" title="线性筛 $\tau$"></a>线性筛 $\tau$</h4><p>约数个数函数 $\tau=\sigma_0$ 是积性函数，即约束的 $0$ 次幂和，定义为</p>
<script type="math/tex; mode=display">
\tau(n)=\sigma_0(n)=\sum [d | n]</script><p>利用多集合的计数思路，对于 $n$ 的标准分解，有</p>
<script type="math/tex; mode=display">
\tau(n)=\sigma_0(n)=\prod_{i=1}^m (k_i+1)</script><p>同样直接分类讨论即可，但注意维护 $g(n)$ 和计算 $\tau(p^k)$ 的位置。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$n$ 与 $p_1$ 关系</th>
<th style="text-align:center">$\tau(n)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$n$ 是素数 $p_1$</td>
<td style="text-align:center">$2$</td>
</tr>
<tr>
<td style="text-align:center">$n=p_1\times i$，且 $p_1\nmid i$</td>
<td style="text-align:center">$\tau(p_1)\times \tau(i)=2\tau(i)$</td>
</tr>
<tr>
<td style="text-align:center">$n=p_1\times i$，且 $p_1\mid i$</td>
<td style="text-align:center">$\tau(p_1^k)\times\tau(j)$</td>
</tr>
</tbody>
</table>
</div>
<div><div class="fold_hider"><div class="close hider_title">Sample-Code</div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g[<span class="number">1</span>] = tau[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mindiv[i]) &#123;</span><br><span class="line">       	g[i] = i;</span><br><span class="line">        tau[i] = <span class="number">2</span>;</span><br><span class="line">        prime[++tot] = mindiv[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, temp; j &lt;= tot; ++j) &#123;</span><br><span class="line">        temp = prime[j] * i;</span><br><span class="line">        <span class="keyword">if</span> (prime[j] &gt; mindiv[i] || temp &gt; n) <span class="keyword">break</span>;</span><br><span class="line">    	<span class="keyword">if</span> (prime[j] == mindiv[i]) &#123;</span><br><span class="line">            g[temp] = g[i] * prime[j];</span><br><span class="line">            <span class="keyword">if</span> (g[temp] == temp) tau[temp] = tau[g[i]] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> tau[temp] = tau[g[temp]] * tau[i / g[i]];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        g[temp] = prime[j];</span><br><span class="line">        mindiv[temp] = prime[j];</span><br><span class="line">        tau[temp] = <span class="number">2</span> * tau[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h4 id="线性筛-sigma"><a href="#线性筛-sigma" class="headerlink" title="线性筛 $\sigma$"></a>线性筛 $\sigma$</h4><p>约数和函数 $\sigma=\sigma_1$ 是积性函数，即约束的 $1$ 次幂和，定义为</p>
<script type="math/tex; mode=display">
\sigma(n)=\sigma_1(n)=\sum_{d|n} d</script><p>利用多集合的计数思路，对于 $n$ 的标准分解，有</p>
<script type="math/tex; mode=display">
\sigma(n)=\sigma_1(n)=\prod_{i=1}^m \sum_{j=0}^{k_i} p_i^j</script><p>同样直接分类讨论即可，注意维护 $g(n),k(n)$ 和计算 $\sigma(p^k)$ 的位置 。</p>
<p>由于计算 $\sigma(p^k)$ 单次复杂度为 $O(\log k)$，总复杂度依然保持线性。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$n$ 与 $p_1$ 关系</th>
<th style="text-align:center">$\sigma(n)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$n$ 是素数 $p_1$</td>
<td style="text-align:center">$p_1+1$</td>
</tr>
<tr>
<td style="text-align:center">$n=p_1\times i$，且 $p_1\nmid i$</td>
<td style="text-align:center">$\sigma(p_1)\times \sigma(i)=(p_1+1)\times \sigma(i)$</td>
</tr>
<tr>
<td style="text-align:center">$n=p_1\times i$，且 $p_1\mid i$</td>
<td style="text-align:center">$\sigma(p_1^k)\times\sigma(j)$</td>
</tr>
</tbody>
</table>
</div>
<div><div class="fold_hider"><div class="close hider_title">Sample-Code</div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g[<span class="number">1</span>] = k[<span class="number">1</span>] = sigma[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mindiv[i]) &#123;</span><br><span class="line">       	g[i] = i;</span><br><span class="line">        k[i] = <span class="number">1</span>;</span><br><span class="line">        sigma[i] = i + <span class="number">1</span>;</span><br><span class="line">        prime[++tot] = mindiv[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, temp; j &lt;= tot; ++j) &#123;</span><br><span class="line">        temp = prime[j] * i;</span><br><span class="line">        <span class="keyword">if</span> (prime[j] &gt; mindiv[i] || temp &gt; n) <span class="keyword">break</span>;</span><br><span class="line">    	<span class="keyword">if</span> (prime[j] == mindiv[i]) &#123;</span><br><span class="line">            k[temp] = k[i] + <span class="number">1</span>;</span><br><span class="line">            g[temp] = g[i] * prime[j];</span><br><span class="line">            <span class="keyword">if</span> (g[temp] == temp) sigma[temp] = sigma[g[i]] + fpow(prime[j], k[i]);</span><br><span class="line">            <span class="keyword">else</span> sigma[temp] = sigma[g[temp]] * sigma[i / g[i]];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        g[temp] = prime[j];</span><br><span class="line">        k[temp] = <span class="number">1</span>;</span><br><span class="line">        mindiv[temp] = prime[j];</span><br><span class="line">        sigma[temp] = (prime[j] + <span class="number">1</span>) * sigma[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h4 id="线性筛-sigma-k"><a href="#线性筛-sigma-k" class="headerlink" title="线性筛 $\sigma_k$"></a>线性筛 $\sigma_k$</h4><p>约数幂和函数 $\sigma_k$ 是积性函数，即约束的 $k$ 次幂和，定义为</p>
<script type="math/tex; mode=display">
\sigma_k(n)=\sum_{d|n} d^k</script><p>为避免重复，用大写 $K$ 表示所求幂次。</p>
<p>同样直接分类讨论即可，注意维护 $g(n),k(n)$ 和计算 $\sigma_k(p^k)$ 的位置 。</p>
<p>此时计算 $\sigma_k(p^k)$ 单次复杂度为 $O(\log (k\times K))$，总复杂度<strong>不再保持线性</strong>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$n$ 与 $p_1$ 关系</th>
<th style="text-align:center">$\sigma_k(n)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$n$ 是素数 $p_1$</td>
<td style="text-align:center">$p_1^{K}+1$</td>
</tr>
<tr>
<td style="text-align:center">$n=p_1\times i$，且 $p_1\nmid i$</td>
<td style="text-align:center">$\sigma(p_1)\times \sigma(i)$</td>
</tr>
<tr>
<td style="text-align:center">$n=p_1\times i$，且 $p_1\mid i$</td>
<td style="text-align:center">$\sigma(p_1^k)\times\sigma(j)$</td>
</tr>
</tbody>
</table>
</div>
<div><div class="fold_hider"><div class="close hider_title">Sample-Code</div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g[<span class="number">1</span>] = k[<span class="number">1</span>] = sigma[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mindiv[i]) &#123;</span><br><span class="line">       	g[i] = i;</span><br><span class="line">        k[i] = <span class="number">1</span>;</span><br><span class="line">        sigma[i] = fpow(i, K) + <span class="number">1</span>;</span><br><span class="line">        prime[++tot] = mindiv[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, temp; j &lt;= tot; ++j) &#123;</span><br><span class="line">        temp = prime[j] * i;</span><br><span class="line">        <span class="keyword">if</span> (prime[j] &gt; mindiv[i] || temp &gt; n) <span class="keyword">break</span>;</span><br><span class="line">    	<span class="keyword">if</span> (prime[j] == mindiv[i]) &#123;</span><br><span class="line">            k[temp] = k[i] + <span class="number">1</span>;</span><br><span class="line">            g[temp] = g[i] * prime[j];</span><br><span class="line">            <span class="keyword">if</span> (g[temp] == temp) sigma[temp] = sigma[g[i]] + fpow(prime[j], k[i] * K);</span><br><span class="line">            <span class="keyword">else</span> sigma[temp] = sigma[g[temp]] * sigma[i / g[i]];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        g[temp] = prime[j];</span><br><span class="line">        k[temp] = <span class="number">1</span>;</span><br><span class="line">        mindiv[temp] = prime[j];</span><br><span class="line">        sigma[temp] = sigma[prime[j]] * sigma[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>当 $K$ 很大的时候显然会超时，例如计算 $n=K=10^7$ 时，可以考虑打表。</p>
<p>找到 $p_i,k_i$ 可能的最大值，得到 $p\le 4\times 10^3,k_i\le 25$，直接记忆化省掉快速幂。</p>
<div><div class="fold_hider"><div class="close hider_title">Sample-Code</div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">10</span>, p = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c[N] 即文中 k[N]</span></span><br><span class="line"><span class="keyword">int</span> n, k, pri[N], tot, c[N], mn[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line">ll f[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>( ; b ; b &gt;&gt;= <span class="number">1</span>, a = (ll) a * a % p) <span class="keyword">if</span>(b &amp; <span class="number">1</span>) r = (ll) r * a % p;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val[<span class="number">4000</span>][<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> mn, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(val[mn][c] != <span class="number">-1</span>) <span class="keyword">return</span> val[mn][c];</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= c ; ++ j) r = ((ll) r + fpow(mn, (ll) j * k)) % p;</span><br><span class="line">	<span class="keyword">return</span> val[mn][c] = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(val, <span class="number">-1</span>, <span class="keyword">sizeof</span> val);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">	ans = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i]) pri[++ tot] = i, f[i] = <span class="number">1</span> + fpow(i, k), g[i] = i, c[i] = <span class="number">1</span>, mn[i] = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= tot &amp;&amp; (ll) i * pri[j] &lt;= n ; ++ j) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = i * pri[j];</span><br><span class="line">			vis[x] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i % pri[j] == <span class="number">0</span>) &#123;</span><br><span class="line">				f[x] = f[i / g[i]] * F(mn[i], c[i] + <span class="number">1</span>) % p;</span><br><span class="line">				g[x] = g[i] * pri[j];</span><br><span class="line">				c[x] = c[i] + <span class="number">1</span>;</span><br><span class="line">				mn[x] = pri[j];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> f[x] = f[i] * f[pri[j]] % p, g[x] = pri[j], c[x] = <span class="number">1</span>, mn[x] = pri[j];</span><br><span class="line">		&#125;</span><br><span class="line">		ans = (ans + f[i]) % p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<hr>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>对于一些未定义积性函数，线性筛的应用。</p>
<h4 id="2018-南京网络预赛-Sum"><a href="#2018-南京网络预赛-Sum" class="headerlink" title="[2018 南京网络预赛] Sum"></a><a href="https://nanti.jisuanke.com/t/A1956" target="_blank" rel="noopener">[2018 南京网络预赛] Sum</a></h4><p>定义 $f(x)$ 为满足以下条件的<strong>有序</strong>二元组 $(a,b)$ 的方案数</p>
<ul>
<li>$x = a\times b$</li>
<li>$a$ 和 $b$ 均无平方因子 ( $\mu(a)\neq 0,\mu(b)\neq 0$ )</li>
</ul>
<p>求 $\sum_{i=1}^n f(i)$，数据范围 $n\le 2\times 10^7$ </p>
<p><strong>Solution</strong></p>
<p>显然 $f(x)=\sum_{d|x} abs(\mu(d)\mu(\frac nd))$，是积性函数（相当于是重定义让 $\mu\ge 0$， $\mu*\mu$ ）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$n$ 与 $p_1$ 关系</th>
<th style="text-align:center">$f(n)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$n$ 是素数 $p_1$</td>
<td style="text-align:center">$2$</td>
</tr>
<tr>
<td style="text-align:center">$n=p_1\times i$，且 $p_1\nmid i$</td>
<td style="text-align:center">$f(p_1)\times f(i)=2f(i)$</td>
</tr>
</tbody>
</table>
</div>
<p>对于 $n=p_1\times i$，且 $p_1\mid i$ 的情况，讨论：</p>
<ul>
<li><p>若 $p_1 | \frac i{p_1}$ 即 $p_1 | \frac{n}{p_1^2}$ 时， $n$ 中 $p_1$ 的指数至少为 $3$ ，无论如何划分 $(a,b)$，都有一个 $\mu = 0$ ， $f(n) = 0$ </p>
</li>
<li><p>否则 $p_1$ 的指数为 $2$ ， 产生贡献必须把 $p_1$ 分给 $a$ 和 $b$ 各一个，即方案数 $f(n) = f(\frac{n}{p_1^2})$</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20000007ll</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> c = getchar();</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">    x = x * <span class="number">10</span> + (c ^ <span class="number">48</span>);</span><br><span class="line">    c = getchar();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot, f[N], prm[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) prm[++tot] = i, f[i] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j) &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="number">1l</span>l * i * prm[j] &gt;= N) <span class="keyword">break</span>;</span><br><span class="line">       vis[i * prm[j]] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (i % prm[j] == <span class="number">0</span>) &#123;</span><br><span class="line">         f[i * prm[j]] = ((i / prm[j]) % prm[j]) ? f[i / prm[j]] : <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       f[i * prm[j]] = f[i] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">int</span> t = rd();</span><br><span class="line">  <span class="keyword">while</span> (t--) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[rd()]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(还有一种做法即 $f=\mu^2 *\mu^2$ ，反演即可，查询单次 $O(\sqrt n)$ ，参考<a href="https://www.cnblogs.com/lfri/p/11382166.html" target="_blank" rel="noopener">这里</a>)</p>
]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>线性筛</tag>
      </tags>
  </entry>
</search>
